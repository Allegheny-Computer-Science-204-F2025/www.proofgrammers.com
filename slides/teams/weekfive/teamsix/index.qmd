---
title: "Better understanding the `startsWithZ` Proof by Contradiction"
description: "Explore the limits of `startsWithZ`"
date: "2025-10-02"
date-format: long
author: Alexander Goddard, Issei Hasegawa, Javier Bejarano Jimenez, Miguel Orti Vila
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

## Introduction

::: {.fragment}
- Today, we will talk about the problem called `startsWithZ`.  
- The question is simple: **Can we decide whether a program’s output begins with the letter “Z”?**
- At first glance, this looks easy—just run the program and check its output.  
- However, we will see that this problem is actually incomputable,
  and we will explain why using a **proof by contradiction**.  
:::

## Proof by Contradiction

::: {.fragment}

**Step 1 — Assumption**  
- Suppose `startsWithZ` exists and always decides correctly.  

**Step 2 — Trap Construction**
- Then we can define:  
  - `startsWithZSelf(P)`: checks if program `P`, when given itself as input, outputs a string that **starts with Z**.  
  - `notStartsWithZSelf(P)`: does the opposite — it returns “yes” if `P`, when given itself as input, outputs a string that **does not start with Z**.  

**Step 3 — Contradiction**  
- Consider the program `weirdStartsWithZ`, which calls `startsWithZ` on its own code and returns the opposite:  
  - If `startsWithZ` says “yes,” it returns “no.”  
  - If `startsWithZ` says “no,” it returns “yes.”  

- When `weirdStartsWithZ` is run on itself, it returns “yes” **iff** it returns “no.”  

- This is impossible, so our assumption was false.  

**Conclusion**  
- Therefore, `startsWithZ` cannot exist.  

:::

## Why the `startsWithZ` Proof by Contradiction can be Confusing

::: {.fragment}
- The concept of self-referential code can be difficult to understand. What will happen when the code runs on itself can be tough to wrap your head around
- It seems like something that should be computable even though it isn't
- Each step is carefully built on top of the other so if you misunderstand one part the rest will seem confusing
- Due to the intricacy of steps inconsistency in wording/phrasing can lead to major confusion
:::

## Some Ways that Helped Us Better Understand It 

::: {.fragment}
- Focus: Static vs. Dynamic Analysis 
- **Static Analysis**  
  - Analyze the *code structure* without running it (just look at).
  - Typicaly computable
  - Example: 'countLine', 'beginWithA'

- **Dynamic Analysis** 
  - Analyze the *output* of a program.
  - Imagine *running the program with itself as input*.
  - More likely to be uncompuatble
  - Example: 'yesOnString', 'crashOnstring'
:::

## Conclusion

::: {.fragment}
  
:::
